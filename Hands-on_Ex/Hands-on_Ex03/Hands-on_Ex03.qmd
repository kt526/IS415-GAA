---
title: "Hands-on Exercise 3: 1st Order Spatial Point Patterns Analysis Methods"
execute:
  warning: false
date: 01/17/2024
date-modified: last-modified
---

# 1.0 Introduction

## 1.1 Getting Started

In this hands-on exercise, we will be using the following packages:

-   maptools for manipulating geographic data

    (*Note: We will use maptools to convert Spatial objects into ppp format of spatstat)*

-   raster for reading, writing, manipulating, analyzing and modelling of gridded spatial data

    (*Note: We will use raster to convert image output generated by spatstat into raster format)*

-   [sf](https://cran.r-project.org/web/packages/sf/) for handling geospatial data

-   spatstat for point pattern analysis

    (*Note: We will use spatstat to perform 1^st^ and 2^nd^ order spatial point patterns analysis and derive kernel density estimation (KDE) layer)*

-   [tmap](https://cran.r-project.org/web/packages/tmap/) for creating thematic maps such as choropleth and proportional symbol maps,

```{r}
install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")
```

```{r}
pacman::p_load(maptools, raster, sf, spatstat, tmap)
```

# 2.0 Data Acquisition

We will be using 3 datasets in this exercise:

-   Pre-Schools Location from [data.gov.sg](https://beta.data.gov.sg/collections/2015/datasets/d_5d668e3f544335f8028f546827b773b4/view)

-   MP14_SUBZONE_WEB_PL from [data.gov.sg](https://beta.data.gov.sg/collections/1708/view)

-   MasterPlan2019SubzoneBoundaryNoSeaKML from [data.gov.sg](https://beta.data.gov.sg/collections/1749/view)

## 2.1 Extracting Geospatial Data Sets

Following a structure similar to [Hands-on Exercise 01](../Hands-on_Ex01/Hands-on_Ex01.html), start by creating a new folder labeled `Hands-on_Ex03`. Within this folder, create a sub-folder named `data`. Inside the `data` sub-folder, create one additional sub-folders and rename them `geospatial`.

> *Tip: We can shorten MasterPlan2019SubzoneBoundaryNoSeaKML so it is easy to import the dataset.*

Let's rename `MasterPlan2019SubzoneBoundaryNoSeaKML` to `MP19_SUBZONE_BoundaryNoSea`.

Unzip `MasterPlan2014SubzoneBoundaryWebSHP.zip` and place all the unzipped files, `PreSchoolsLocation.geojson` and `MP19_SUBZONE_BoundaryNoSea.kml` into the `geospatial` sub-folder.

# 3.0 Geospatial Data Handling

## 3.1 Importing Geospatial Data

In the previous exercises, we have learnt to import geospatial data into RStudio by using *st_read()* of **sf** package. Let’s try it now!

```{r}
childcare_sf <- st_read("data/geospatial/ChildCareServices.geojson")
```

```{r}
mpsz_sf <- st_read(dsn = "data/geospatial", 
                layer = "MP14_SUBZONE_WEB_PL")
```

```{r}
sgsz_sf <- st_read(dsn = "data/geospatial/MP19_SUBZONE_BoundaryNoSea.kml")
```

## **3.2 Checking the Contents of A Simple Feature Data Frame**

### **3.2.1 Using st_geometry() to check for inappropriate coordinate systems**

```{r}
st_geometry(childcare_sf)
```

```{r}
st_geometry(mpsz_sf)
```

```{r}
st_geometry(sgsz_sf)
```

You might have observed variations in the coordinate systems among the data frames. Recall in [Hands-on Exercise 01](../Hands-on_Ex01/Hands-on_Ex01.html#working-with-projections), it is a common practice to transform original data from geographical coordinate system to projected coordinate system.

-   `childcare_sf` and `sgsz_sf` uses **WGS 84** (geographic coordinate system)

-   `mpsz_sf` uses uses **SVY21** (projected coordinate system)

Let's perform projection transformation on `childcare_sf` and `sgsz_sf` using *st_transform()* of **sf** package.

```{r}
childcare3414 <- st_transform(childcare_sf, 
                              crs = 3414)
```

```{r}
sgsz3414 <- st_transform(sgsz_sf,
                         crs = 3414)
```

Now, we will display the contents of `childcare3414` and `sgsz3414`.

```{r}
st_geometry(childcare3414)
```

```{r}
st_geometry(sgsz3414)
```

Notice that both `childcare3414` and `sgsz3414` are now in SVY21 projected coordinate system.

### **3.2.2 Using st_crs() to check for missing/inaccurate coordinate systems**

> **DIY: Using the appropriate sf function you learned in Hands-on Exercise 2, retrieve the referencing system information of these geospatial data.**

To retrieve coordinate reference system from sf object, we need to use *st_crs()* from **sf** package.

```{r}
st_crs(childcare3414)
```

```{r}
st_crs(mpsz_sf)
```

```{r}
st_crs(sgsz3414)
```

Although `mpsz_sf` is projected in **SVY21**, the output near the end indicates that EPSG is 9001. This is a wrong EPSG code. The correct EPSG code for **SVY21** should be [3414](#0). Let’s change it using *st_transform()* of **sf** package.

> **DIY: Using the method you learned in Lesson 2, assign the correct crs to `mpsz_sf`.**

```{r}
mpsz3414 <- st_transform(mpsz_sf, 3414)
st_crs(mpsz3414)
```

Notice that the EPSG code is **3414** now.

# **4.0 Geospatial Visualization**

After checking the coordinate reference system of each geospatial data frame, it is also useful for us to plot a map to show their spatial patterns.

> **DIY: Using the mapping methods you learned in Hands-on Exercise 3, prepare a map as shown below.**

```{r}
tm_shape(sgsz3414) +
  tm_polygons() +
tm_shape(mpsz3414) +
  tm_polygons() +
tm_shape(childcare3414)+
  tm_dots()
```

Notice that all the geospatial layers are within the same map extend. This shows that their referencing system and coordinate values are referred to similar spatial context. This is very important in any geospatial analysis.

Alternatively, we can also prepare a pin map using *tmap_mode()* with the `view` option for interactive mode.

```{r}
tmap_mode("view")
tm_shape(childcare3414)+
  tm_dots()
```

> *Reminder: Always remember to switch back to plot mode after the interactive map. This is because, each interactive mode will consume a connection. You should also avoid displaying ecessive numbers of interactive maps (i.e. not more than 10) in one RMarkdown document when publish on Netlify.*

```{r}
tmap_mode("plot")
```

# **5.0 Geospatial Data wrangling**

Converting simple feature data frames to sp's Spatial\* classes in geospatial analysis is necessary because many geospatial analysis packages in R, such as "spatial" and "raster," require input geospatial data in the form of sp's Spatial\* classes.

## **5.1 Converting sf data frames to sp’s Spatial\* class**

Let's convert sf data frames into sp's Spatial\* class using [*as_Spatial()*](https://r-spatial.github.io/sf/reference/coerce-methods.html) of **sf** package.

```{r}
childcare <- as_Spatial(childcare3414)
mpsz <- as_Spatial(mpsz3414)
sg <- sgsz_sf %>% st_zm() %>% as_Spatial()
```

```{r}
childcare
```

```{r}
mpsz
```

```{r}
sg
```

Notice that the geospatial data have been converted into their respective sp’s Spatial\* classes now.

## 5.2 **Converting the Spatial\* class into generic sp format**

**spatstat** requires the analytical data in ***ppp*** object form. There is no direct way to convert a Spatial\* classes into ***ppp*** object. We need to convert the ***Spatial*** **classes**\* into ***Spatial*** object first.

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
mpsz_sp <- as(mpsz, "SpatialPolygons")
sg_sp <- as(sg, "SpatialPolygons")
```

```{r}
childcare_sp
```

```{r}
mpsz_sp
```

```{r}
sg_sp
```

## **5.3 Converting the generic sp format into spatstat’s ppp format**

Now, we will use *as.ppp()* function of **spatstat** to convert the spatial data into **spatstat**’s ***ppp*** object format.
