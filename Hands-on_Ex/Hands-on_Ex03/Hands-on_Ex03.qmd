---
title: "Hands-on Exercise 3: 1st Order Spatial Point Patterns Analysis Methods"
execute:
  warning: false
date: 01/17/2024
date-modified: last-modified
code-annotations: hover
---

# 1.0 Introduction

## 1.1 Getting Started

In this hands-on exercise, we will be using the following packages:

-   maptools for manipulating geographic data

    (*Note: We will use maptools to convert Spatial objects into ppp format of spatstat)*

-   raster for reading, writing, manipulating, analyzing and modelling of gridded spatial data

    (*Note: We will use raster to convert image output generated by spatstat into raster format)*

-   [sf](https://cran.r-project.org/web/packages/sf/) for handling geospatial data

-   spatstat for point pattern analysis

    (*Note: We will use spatstat to perform 1^st^ and 2^nd^ order spatial point patterns analysis and derive kernel density estimation (KDE) layer)*

-   [tmap](https://cran.r-project.org/web/packages/tmap/) for creating thematic maps such as choropleth and proportional symbol maps,

```{r}
install.packages("maptools", repos = "https://packagemanager.posit.co/cran/2023-10-13")
```

```{r}
pacman::p_load(maptools, raster, sf, spatstat, tmap)
```

# 2.0 Data Acquisition

We will be using 2 datasets in this exercise:

-   Pre-Schools Location from [data.gov.sg](https://beta.data.gov.sg/collections/2064/view)

-   MP14_SUBZONE_WEB_PL from [data.gov.sg](https://beta.data.gov.sg/collections/1708/view)

## 2.1 Extracting Geospatial Data Sets

Following a structure similar to [Hands-on Exercise 01](../Hands-on_Ex01/Hands-on_Ex01.html), start by creating a new folder labeled `Hands-on_Ex03`. Within this folder, create a sub-folder named `data`. Inside the `data` sub-folder, create one additional sub-folders and rename them `geospatial`.

Unzip `MasterPlan2014SubzoneBoundaryWebSHP.zip` and place all the unzipped files, `PreSchoolsLocation.geojson` into the `geospatial` sub-folder.

# 3.0 Geospatial Data Handling

## 3.1 Importing Geospatial Data

In the previous exercises, we have learnt to import geospatial data into RStudio by using *st_read()* of **sf** package. Let’s try it now!

```{r}
childcare_sf <- st_read("data/geospatial/PreSchoolsLocation.geojson")
```

```{r}
mpsz_sf <- st_read(dsn = "data/geospatial", 
                layer = "MP14_SUBZONE_WEB_PL")
```

```{r}
coastaloutline_sf <- st_union(mpsz_sf)
```

## 3.2 Checking the Contents of A Simple Feature Data Frame

### 3.2.1 Using st_geometry() to check for inappropriate coordinate systems

```{r}
st_geometry(childcare_sf)
```

```{r}
st_geometry(mpsz_sf)
```

```{r}
st_geometry(coastaloutline_sf)
```

You might have observed variations in the coordinate systems among the data frames. Recall in [Hands-on Exercise 01](../Hands-on_Ex01/Hands-on_Ex01.html#working-with-projections), it is a common practice to transform original data from geographical coordinate system to projected coordinate system.

-   `childcare_sf` uses **WGS 84** (geographic coordinate system)

-   `mpsz_sf` and `coastal_outline_sf` uses uses **SVY21** (projected coordinate system)

Let's perform projection transformation on `childcare_sf` and `sgsz_sf` using *st_transform()* of **sf** package.

```{r}
childcare3414 <- st_transform(childcare_sf, 
                              crs = 3414)
```

Now, we will display the contents of `childcare3414`.

```{r}
st_geometry(childcare3414)
```

Notice that `childcare3414` is now in **SVY21** projected coordinate system.

### 3.2.2 Using st_crs() to check for missing/inaccurate coordinate systems

> **DIY: Using the appropriate sf function you learned in Hands-on Exercise 2, retrieve the referencing system information of these geospatial data.**

To retrieve coordinate reference system from sf object, we need to use *st_crs()* from **sf** package.

```{r}
st_crs(childcare3414)
```

```{r}
st_crs(mpsz_sf)
```

```{r}
st_crs(coastaloutline_sf)
```

Although `mpsz_sf` and `coastaloutline_sf` are projected in **SVY21**, the output near the end indicates that EPSG is 9001. This is a wrong EPSG code. The correct EPSG code for **SVY21** should be [3414](#0). Let’s change it using *st_transform()* of **sf** package.

> **DIY: Using the method you learned in Lesson 2, assign the correct crs to `mpsz_sf`** and **`coastaloutline_sf`**.

```{r}
mpsz3414 <- st_transform(mpsz_sf, 3414)
st_crs(mpsz3414)
```

```{r}
coastaloutline3414 <- st_transform(coastaloutline_sf, 3414)
st_crs(coastaloutline3414)
```

Notice that the EPSG code are in **3414** now.

# 4.0 Geospatial Visualization

After checking the coordinate reference system of each geospatial data frame, it is also useful for us to plot a map to show their spatial patterns.

> **DIY: Using the mapping methods you learned in Hands-on Exercise 3, prepare a map as shown below.**

```{r}
tm_shape(coastaloutline3414) +
  tm_polygons() + 
tm_shape(mpsz3414) +
  tm_polygons() + 
tm_shape(childcare3414)+
  tm_dots()
```

Notice that all the geospatial layers are within the same map extend. This shows that their referencing system and coordinate values are referred to similar spatial context. This is very important in any geospatial analysis.

Alternatively, we can also prepare a pin map using *tmap_mode()* with the `view` option for interactive mode.

```{r}
tmap_mode("view")
tm_shape(childcare3414)+
  tm_dots()
```

> *Reminder: Always remember to switch back to plot mode after the interactive map. This is because, each interactive mode will consume a connection. You should also avoid displaying ecessive numbers of interactive maps (i.e. not more than 10) in one RMarkdown document when publish on Netlify.*

```{r}
tmap_mode("plot")
```

# 5.0 Geospatial Data wrangling

Converting simple feature data frames to sp's Spatial\* classes in geospatial analysis is necessary because many geospatial analysis packages in R, such as "spatial" and "raster," require input geospatial data in the form of sp's Spatial\* classes.

## 5.1 Converting sf data frames to sp’s Spatial\* class

Let's convert sf data frames into sp's Spatial\* class using [*as_Spatial()*](https://r-spatial.github.io/sf/reference/coerce-methods.html) of **sf** package.

```{r}
childcare <- as_Spatial(childcare3414)
mpsz <- as_Spatial(mpsz3414)
coastaloutline <- as_Spatial(coastaloutline3414)
```

```{r}
childcare
```

```{r}
mpsz
```

```{r}
coastaloutline
```

Notice that the geospatial data have been converted into their respective sp’s Spatial\* classes now.

## 5.2 Converting the Spatial\* class into generic sp format

**spatstat** requires the analytical data in ***ppp*** object form. There is no direct way to convert a Spatial\* classes into ***ppp*** object. We need to convert the ***Spatial*** **classes**\* into ***Spatial*** object first.

```{r}
childcare_sp <- as(childcare, "SpatialPoints")
mpsz_sp <- as(mpsz, "SpatialPolygons")
coastaloutline_sp <- as(coastaloutline, "SpatialPolygons")
```

```{r}
childcare_sp
```

```{r}
mpsz_sp
```

```{r}
coastaloutline_sp
```

## 5.3 Converting the generic sp format into spatstat’s ppp format

Now, we will use *as.ppp()* function of **spatstat** to convert the spatial data into **spatstat**’s ***ppp*** object format.

```{r}
childcare_ppp <- as(childcare_sp, "ppp")
```

Now, let us plot ***childcare_ppp*** and examine the different.

```{r}
plot(childcare_ppp)
```

We can take a quick look at the summary statistics of the newly created ppp object by using *summary()*.

```{r}
summary(childcare_ppp)
```

> *Notice the warning message about duplicates. In spatial point patterns analysis, an issue of significant is the presence of duplicates. The statistical methodology used for spatial point patterns processes is based largely on the assumption that process are simple, that is, that the points cannot be coincident.*

## 5.4 Handling Duplicated Points

To check for duplication in a **ppp** object, we can do the following:

```{r}
any(duplicated(childcare_ppp))
```

To count the number of co-incidence point, we will use *multiplicity()*.

```{r}
#| eval: false
multiplicity(childcare_ppp)
```

To know the total number of locations that have more than one point event, we can use *sum()*:

```{r}
sum(multiplicity(childcare_ppp))
```

The output shows that there are 2451 duplicated point events.

To view the locations of these duplicate point events, we will plot the childcare data.

```{r}
tmap_mode("view")
tm_shape(childcare) +
  tm_dots(alpha=0.4, 
          size=0.05)
```

```{r}
tmap_mode("plot")
```

There are 3 ways to handle duplicated points:

1.  Delete the duplicates
2.  Use jittering
3.  Make each point "unique" and then attach the duplicates of the points to the patterns as marks

In this hands-on exercise, we will implement the jittering approach.

```{r}
childcare_ppp_jit <- rjitter(childcare_ppp,
                             retry=TRUE,
                             nsim=1,
                             drop=TRUE)
```

> **DIY: Using the method you learned in previous section, check if any duplicated point in this geospatial data.**

To check for any duplicated point, recall *any(duplicated()).*

```{r}
any(duplicated(childcare_ppp_jit))
```

## 5.5 Creating owin object

When analysing spatial point patterns, it is a good practice to confine the analysis with a geographical area like Singapore boundary. In **spatstat**, an object called ***owin*** is specially designed to represent this polygonal region.

To convert `sg` SpatialPolygon object into **owin** object of spatstat, run the following:

```{r}
sg_owin <- as(coastaloutline_sp, "owin")
```

The ouput object can be displayed by using *plot()* and *summary():*

```{r}
plot(sg_owin)
```

```{r}
summary(sg_owin)
```

## 5.6 Combining point events object and owin object

In this last step of geospatial data wrangling, we will extract childcare events that are located within Singapore.

```{r}
childcareSG_ppp <- childcare_ppp[sg_owin]
```

The output object combined both the point and polygon feature in one ppp object class.

```{r}
#| eval: false
summary(childcareSG_ppp)
```

> **DIY: Using the method you learned in previous exercise, plot the newly derived childcareSG_ppp as shown below.**

```{r}
plot(childcareSG_ppp)
```

# 6.0 1^st^ Order Spatial Point Pattern Analysis (SPPA)

In this section, we will perform 1st order SPPA by using **spatstat** package. Our main focus will be:

-   Deriving **kernel density estimation (KDE)** layer for visualization and exploring the intensity of point processes,

-   Performing **Confirmatory Spatial Point Patterns Analysis** by using **Nearest Neighbour** statistics

## 6.1 Kernel Density Estimation (KDE)

What is Kernel Density Estimation? Kernel Density Estimation, KDE, is a non-parametric technique that estimates the probability density function of a continuous variable. In simple terms, it smooths out your data by placing a kernel (usually a Gaussian kernel is used as default) at each data point and then summing up these kernels to create a continuous curve. This curve offers a more refined view of how data points are distributed across the variable's range

Read more about KDE [here](https://medium.com/@sruthy.sn91/kernel-density-estimation-a-smooth-path-to-data-visualization-20e4eb1da1ea#:~:text=Understanding%20Kernel%20Density%20Estimation,to%20create%20a%20continuous%20curve.).

How does KDE actually works?

![Fig 1. Equation for Gaussian kernel](imgs/kde_eqn.png){width="300"}

Read more about how KDE works [here](https://medium.com/analytics-vidhya/kernel-density-estimation-kernel-construction-and-bandwidth-optimization-using-maximum-b1dfce127073).

### 6.1.1 Computing KDE using Automatic Bandwidth Selection method

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian") 
```

```{r}
plot(kde_childcareSG_bw)
```

Notice how the density values of the legend range from 0 to 0.000035. This is way too small to comprehend ! 👀

Why is this the case? This is because the default unit measurement for SVY 21 is in meter.

As a result, the density values computer is in " umber of points per square meter".

> *Note: We can retrieve the bandwidth used to compute the KDE layer using bw.diggle().*

```{r}
bw <- bw.diggle(childcareSG_ppp)
bw
```

### 6.1.2 Rescaling KDE values

Noting that the default unit measurement for SVY 21 is in meter, is it possible to convert the unit measurement into kilometer? To do so, we can use the *rescale()*.

```{r}
childcareSG_ppp.km <- rescale(childcareSG_ppp, 1000, "km")
```

Let's run density() using `childcareSG_ppp.km` (a.k.a. rescaled dataset) and plot out the KDE map.

```{r}
kde_childcareSG_bw <- density(childcareSG_ppp.km,
                              sigma=bw.diggle,
                              edge=TRUE,
                              kernel="gaussian")
plot(kde_childcareSG_bw)
```

Notice that output image looks identical to the earlier version, the only changes in the data values (refer to the legend).

### 6.1.3 Working with different automatic bandwidth methods

Besides *bw.diggle()*, there are three other **spatstat** functions that can be used to determine the bandwidth, they are:

-   *bw.CvL()*,

-   *bw.scott()*, and

-   *bw.ppl()*

Let's take a look at the bandwidth returned by these automatic bandwidth calculation methods.

```{r}
bw.diggle(childcareSG_ppp.km)
```

```{r}
bw.CvL(childcareSG_ppp.km)
```

```{r}
bw.scott(childcareSG_ppp.km)
```

```{r}
bw.ppl(childcareSG_ppp.km)
```

There is ongoing debate regarding the optimal methods for pattern detection. However, according to a study, it is recommended to employ *bw.ppl()* when dealing with patterns predominantly characterized by tight clusters. On the other hand, *bw.diggle()* is suggested for detecting a single tight cluster within a background of random noise. In comparing *bw.diggle()* and *bw.ppl()*:

```{r}
kde_childcareSG.ppl <- density(childcareSG_ppp.km, 
                               sigma=bw.ppl, 
                               edge=TRUE,
                               kernel="gaussian")
par(mfrow=c(1,2), mar = c(2, 2, 2, 2))
plot(kde_childcareSG_bw, main = "bw.diggle")
plot(kde_childcareSG.ppl, main = "bw.ppl")
```

### 6.1.4 Working with different kernel methods

The default kernel method employed in *density.ppp()* is Gaussian. However, there are three alternative options available:

-   Epanechnikov,

-   Quartic, and

-   Dics

```{r}
par(mfrow=c(2,2), mar = c(2, 2, 2, 2))
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="gaussian"), 
     main="Gaussian")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="epanechnikov"), 
     main="Epanechnikov")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="quartic"), 
     main="Quartic")
plot(density(childcareSG_ppp.km, 
             sigma=bw.ppl, 
             edge=TRUE, 
             kernel="disc"),
     main="Disc")
```

### 6.1.5 Computing KDE by using Fixed Bandwidth

Let’s compute a KDE layer by defining a bandwidth of 600 meters. We’ll use a sigma value of 0.6 in this case, as the unit of measurement of our `childcareSG_ppp.km` object is in kilometers, hence the 600m is 0.6km.

```{r}
kde_childcareSG_600 <- density(childcareSG_ppp.km, sigma=0.6, edge=TRUE, kernel="gaussian")
plot(kde_childcareSG_600)
```

A downside of fixed bandwidth is that this method is **very sensitive to highly skewed distributions**.

### 6.1.6 Computing KDE by using Adaptive Bandwidth

One way to overcome this problem is by using adaptive bandwidth with *density.adaptive()* of **spatstat** package.

```{r}
kde_childcareSG_adaptive <- adaptive.density(childcareSG_ppp.km, method="kernel")
plot(kde_childcareSG_adaptive)
```

We can now compare the results of fixed and adaptive kernel density estimation.

```{r}
par(mfrow=c(1,2), mar = c(2, 2, 2, 2))
plot(kde_childcareSG_bw, main = "Fixed bandwidth")
plot(kde_childcareSG_adaptive, main = "Adaptive bandwidth")
```

### 6.1.7 Converting KDE output into grid object and grid object into raster

In order for a KDE output to be suitable for mapping purposes, we can convert it into a grid object.

> Note: The results will be the same.

```{r}
gridded_kde_childcareSG_bw <- as.SpatialGridDataFrame.im(kde_childcareSG_bw)
spplot(gridded_kde_childcareSG_bw)
```

Next, we will convert the gridded kernal density objects into RasterLayer object by using *raster()* of **raster** package.

```{r}
kde_childcareSG_bw_raster <- raster(gridded_kde_childcareSG_bw)
```

Let's take a look at the properties of *kde_childcareSG_bw_raster* RasterLayer.

```{r}
kde_childcareSG_bw_raster
```

> Notice that the crs property is NA.

### 6.1.8 Assigning projection systems

To assign projection systems:

```{r}
projection(kde_childcareSG_bw_raster) <- CRS("+init=EPSG:3414")
kde_childcareSG_bw_raster
```

Lastly, let's visualize raster in cartographic quality map using **tmap** package.

```{r}
tm_shape(kde_childcareSG_bw_raster) + 
  tm_raster("v") +
  tm_layout(legend.position = c("right", "bottom"), frame = FALSE)
```

> *Notice that the raster values are encoded explicitly onto the raster pixel using the values in “v”” field.*

### 6.1.9 Comparing Spatial Point Patterns using KDE

Let’s compare the KDE of childcare at Punggol, Tampines, Chua Chu Kang and Jurong West planning areas.

#### 6.1.9.1 Extracting study area

```{r}
pg = mpsz[mpsz@data$PLN_AREA_N == "PUNGGOL",]
tm = mpsz[mpsz@data$PLN_AREA_N == "TAMPINES",]
ck = mpsz[mpsz@data$PLN_AREA_N == "CHOA CHU KANG",]
jw = mpsz[mpsz@data$PLN_AREA_N == "JURONG WEST",]
```

#### 6.1.9.2 Plotting target planning areas

```{r}
par(mfrow=c(2,2), mar = c(2, 2, 2, 2))
plot(pg, main = "PUNGGOL")
plot(tm, main = "TAMPINES")
plot(ck, main = "CHOA CHU KANG")
plot(jw, main = "JURONG WEST")
```

#### 6.1.9.**3** Converting the spatial point data frame into generic sp format

```{r}
pg_sp = as(pg, "SpatialPolygons")
tm_sp = as(tm, "SpatialPolygons")
ck_sp = as(ck, "SpatialPolygons")
jw_sp = as(jw, "SpatialPolygons")
```

#### 6.1.9.**4** Creating ***owin*** object

```{r}
pg_owin = as(pg_sp, "owin")
tm_owin = as(tm_sp, "owin")
ck_owin = as(ck_sp, "owin")
jw_owin = as(jw_sp, "owin")
```

#### 6.1.9.5 Combining childcare points and the study area

```{r}
childcare_pg_ppp = childcare_ppp_jit[pg_owin]
childcare_tm_ppp = childcare_ppp_jit[tm_owin]
childcare_ck_ppp = childcare_ppp_jit[ck_owin]
childcare_jw_ppp = childcare_ppp_jit[jw_owin]
```

We will use *rescale()* to **transform** the unit of measurement from **metre** to **kilometre**.

```{r}
childcare_pg_ppp.km = rescale(childcare_pg_ppp, 1000, "km")
childcare_tm_ppp.km = rescale(childcare_tm_ppp, 1000, "km")
childcare_ck_ppp.km = rescale(childcare_ck_ppp, 1000, "km")
childcare_jw_ppp.km = rescale(childcare_jw_ppp, 1000, "km")
```

Lastly, let's plot out the four study areas and the locations of the childcare centres.

```{r}
par(mfrow=c(2,2), mar = c(2, 2, 2, 2))
plot(childcare_pg_ppp.km, main="PUNGGOL")
plot(childcare_tm_ppp.km, main="TAMPINES")
plot(childcare_ck_ppp.km, main="CHOA CHU KANG")
plot(childcare_jw_ppp.km, main="JURONG WEST")
```

#### 6.1.9.6 Computing KDE of four planning areas using Automatic Bandwidth Selection method

We will now use the ***bw.diggle()*** automatic bandwidth selection to derive the bandwidths for each planning areas.

```{r}
par(mfrow=c(2,2), mar = c(2, 2, 2, 2))
plot(density(childcare_pg_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="PUNGGOL")
plot(density(childcare_tm_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="TAMPINES")
plot(density(childcare_ck_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="CHOA CHU KANG")
plot(density(childcare_jw_ppp.km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JURONG WEST")
```

#### 6.1.9.7 Computing KDE of four planning areas using Fixed Bandwidth Selection method

For comparison purposes, let's also try computing the KDE layers by defining a fixed bandwidth of 250 meters.

```{r}
par(mfrow=c(2,2), mar = c(2, 2, 2, 2))
plot(density(childcare_pg_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="PUNGGOL")
plot(density(childcare_tm_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="TAMPINES")
plot(density(childcare_ck_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="CHOA CHU KANG")
plot(density(childcare_jw_ppp.km, 
             sigma=0.25, 
             edge=TRUE, 
             kernel="gaussian"),
     main="JURONG WEST")
```

> *Note: The sigma value of 0.25 in this case, as the unit of measurement of our `childcare_tm_ppp.km` object is in kilometers, hence the 250m is 0.25km.*

## 6.2 Nearest Neighbor Analysis

In this section, we will be performing the Clark-Evans test of aggregation for SPPA, using the [*clarkevans.test()*](https://www.rdocumentation.org/packages/spatstat/versions/1.63-3/topics/clarkevans.test) of **statspat** package.

To get started, let's formulate our test hypotheses and state the confidence interval we are using:

-   ***H~0~*** = The distribution of childcare services are randomly distributed.

-   ***H~1~***= The distribution of childcare services are not randomly distributed.

-   The **95% confidence interval** will be used.

> *Note:*
>
> ***Null Hypothesis (H~0~)** – This can be thought of as the implied hypothesis. “Null” meaning “nothing”. This hypothesis states that there is no difference between groups or no relationship between variables. The null hypothesis is a presumption of status quo or no change.*
>
> ***Alternative Hypothesis (H~1~)** – This is also known as the claim. This hypothesis should state what you expect the data to show, based on your research on the topic. This is your answer to your research question.*
>
> *Read more about null and alternative hypotheses [here](https://resources.nu.edu/statsresources/hypothesis#:~:text=Null%20Hypothesis%20(H0)%20%E2%80%93,or%20no%20relationship%20between%20variables.).*

### 6.2.1 Testing spatial point patterns using Clark-Evans Test

``` r
clarkevans.test(childcareSG_ppp,             # <1>
                correction="none",           # <2>
                clipregion="sg_owin",        # <3>
                alternative=c("clustered"),  # <4>
                nsim=99)                     # <5>
```

1.  `childcareSG_ppp`: a spatial point pattern - object of class **ppp**,
2.  `correction`: character string of the type of edge correction to be applied; `correction="none"` denotes **no edge correction is applied**,
3.  `clipregion` a window for guard area correction - object of class **owin**,
4.  `alternative`: string indicating the type of alternative for the hypothesis test. Partially matched; alternative="clustered" denotes the alternative hypothesis is that R \< 1 corresponding to a clustered point pattern
5.  `nsim`: number of Monte Carlo simulations to perform

Note: If the argument `clipregion` is given, then the selected edge corrections will be assumed to include `correction="guard"`.

#### 6.2.1.1 Performing Clark-Evans Test in Choa Chu Kang planning area

```{r}
clarkevans.test(childcare_ck_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

#### 6.2.1.2 Performing Clark-Evans Test in Tampines planning area

```{r}
clarkevans.test(childcare_tm_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```
