---
title: "Hands-on Exercise 1: Geospatial Data Handling and Wrangling with R"
execute:
  warning: false
date: "`r Sys.Date()`"
---

# 1.0 Introduction

## 1.1 Getting Started

In this hands-on exercise, we will be using **sf** and **tidyverse** packages:

-   [sf](https://cran.r-project.org/web/packages/sf/) for handling geospatial data

-   [tidyverse](https://www.tidyverse.org/packages/) for performing data science tasks such as importing, wrangling and visualising data

> *Note: Tidyverse consists of a family of R packages, such as readr, tidyr, and dplyr.*

```{r}
pacman::p_load(tidyverse, sf)
```

# 2.0 Data Acquisition

We will be using datasets from 3 data sources in this exercise:

-   Master Plan 2014 Subzone Boundary (Web) from [data.gov.sg](https://beta.data.gov.sg/collections/1708/view)

-   Pre-Schools Location from [data.gov.sg](https://beta.data.gov.sg/collections/2064/view)

-   Cycling Path from [LTADataMall](https://datamall.lta.gov.sg/content/datamall/en/search_datasets.html?searchText=cycling%20path)

-   Latest version of Singapore Airbnb listing data from [Inside Airbnb](http://insideairbnb.com/get-the-data/)

## 2.1 **Extracting Geospatial and Aspatial Data Sets**

Start by creating a new folder labeled `Hands-on_Ex01`. Within this folder, create a sub-folder named `data`. Inside the `data` sub-folder, create two additional sub-folders and rename them `geospatial` and `aspatial` respectively. Take note of this hierarchical structure as we will be using it to manage our datasets for the upcoming exercises.

Unzip `CyclingPath.zip` and `MasterPlan2014SubzoneBoundaryWebSHP.zip` and place all the unzipped files and `PreSchoolsLocation.kml` into the `geospatial` sub-folder.

Place `listings.csv` into `aspatial` sub-folder.

# 3.0 **Geospatial Data Handling**

## 3.1 **Importing Geospatial Data**

The geospatial data we have are:

-   `MP14_SUBZONE_WEB_PL`, a polygon feature layer in ESRI **shapefile** format

-   `CyclingPath`, a line feature layer in ESRI **shapefile** format

-   `PreSchool`, a point feature layer in **kml** file format

Now that we have obtained our data, it's time to examine the formats they are in and explore the process of importing them into R using *st_read()* of **sf** package. The arguments it takes in depends on the file format.

-   For shapefile format, we need to provide **two arguments**:

    -   `dsn`: To define the data path, a.k.a, the file directory pointing to the shapefile (**no file extension needed!**)

    -   `layer`: To provide the name of the shapefile

-   For kml format, the only argument we need is the **complete path with the kml file extension**

### 3.1.1 Importing polygon feature data in shapefile format

```{r}
mpsz <- st_read(dsn = "data/geospatial", layer = "MP14_SUBZONE_WEB_PL")
```

The message above reveals that the geospatial objects are multipolygon features. There are a total of 323 multipolygon features and 15 fields in mpsz simple feature data frame. mpsz is in **SVY21** projected coordinates systems. The bounding box provides the x extend and y extend of the data.

### 3.1.2 Importing polyline feature data in shapefile form

```{r}
cyclingpath <- st_read(dsn = "data/geospatial", layer = "CyclingPathGazette")
```

The message above reveals that there are a total of 2558 features and 2 fields in cyclingpath linestring feature data frame and it is in **SVY21** projected coordinates system too.

### 3.1.3 Importing GIS data in kml format

```{r}
preschool <- st_read("data/geospatial/PreSchoolsLocation.kml")
```

The message above reveals that preschool is a point feature data frame. There are a total of 2290 features and 2 fields. Different from the previous two simple feature data frame, preschool is in **WGS 84** coordinates system.

## 3.2 Checking the Content of A Simple Feature Data Frame

In this sub-section, we will learn different ways to retrieve information related to the content of a simple feature data frame.

### 3.2.1 Working with *st_geometry()*

```{r}
st_geometry(mpsz)
```

### 3.2.2 Working with *glimpse()*

```{r}
glimpse(mpsz)
```

### 3.2.3 Working with *head()*

```{r}
head(mpsz, n=5)
```

# 4.0 Geospatial Visualization and Projections

## 4.1 Plotting Geospatial Data

In the field of geospatial data science, simply examining feature information is insufficient. We are also interested to visualize geospatial features, and this can be accomplished by using *plot()*.

As illustrated below, the default plot of an sf object showcases a multi-plot visualization of all attributes (up to a reasonable amount).

```{r}
plot(mpsz)
```

However, there might be occasions when our focus is solely on visualizing a particular attribute...

```{r}
plot(mpsz["PLN_AREA_N"])
```

In some cases, we may just want to visualize the geometry (map outline):

```{r}
plot(st_geometry(mpsz))
```

## 4.2 Working with Projections

Map projection is an important property of geospatial data. To effectively process two sets of geospatial data, we need to ensure that both data are projected using similar coordinate system.

In this section, we will learn how to project a simple feature data frame from one coordinate system to another coordinate system. This technical process is referred to as **projection transformation**.

There are two common issues that require projection transformation:

-   Missing or inaccurate coordinate system

-   Inappropriate coordinate systems

### 4.2.1 Missing/inaccurate coordinate system

One of the common issue that can happen during importing geospatial data into RStudio is that the coordinate system of the source data was either missing (such as due to missing .proj for ESRI shapefile) or wrongly assigned during the importing process.

This is an example the coordinate system of `mpsz` simple feature data frame by using *st_crs()* of **sf** package as shown below.

```{r}
st_crs(mpsz)
```

Although `mpsz` simple feature data frame is projected in **SVY21**, the output near the end indicates that EPSG is 9001. This is a wrong EPSG code. The correct EPSG code for **SVY21** should be [3414](https://epsg.io/3414). Let's change it using *st_set_crs()* of **sf** package:

```{r}
mpsz3414 <- st_set_crs(mpsz, 3414)
```

Now, let us check the CSR again.

```{r}
st_crs(mpsz3414)
```

Notice that the EPSG code is **3414** now.

### 4.2.2 Inappropriate coordinate systems

Recall the geospatial data that was introduced in [3.1 Importing Geospatial Data]. You might have observed variations in the coordinate systems among the data frames:

-   `mpsz` and `cyclingpath` uses **SVY21**

-   `preschool` uses **WGS 84**

When we are geoprocessing `preschool`, we might run into issues due to the inappropriate usage of a geographic coordinate system, especially when distance and/or area measurements are essential for the analysis.

Thus, it is a common practiceto transform original data from geographic coordinate system to projected coordinate system.

In the case of `preschool`*, st_set_crs()* is not appropriate and *st_transform()* of **sf** package should be used. This is because we need to reproject `preschool` from one coordinate system to another coordinate system mathemetically.

```{r}
preschool3414 <- st_transform(preschool, 
                              crs = 3414)
```

Let us display the content of `preschool3414`.

```{r}
st_geometry(preschool3414)
```

Notice that it is now in SVY21 projected coordinate system.

> *You might notice a change in the values within the bounding box—they are now extended beyond the typical 0-360 range of decimal degrees commonly used by the majority of geographic coordinate systems.*

# 5.0 Aspatial Data Handling

## 5.1 Importing and Converting Aspatial Data

Since `listings.csv` is in csv file format, we will use read_csv() of **readr** package to import it.

```{r}
listings <- read_csv("data/aspatial/listings.csv")
```

```{r}
list(listings)
```

The output R object is called `listings` and it is a [tibble](#0){style="font-size: 11pt;"} data frame. There are 4252 rows and 16 columns (not features and fields like in our simple data feature frame!)

> Take note of the `latitude` and `longitude` fields as we will be using them in the next phase.

We can convert listing into a simple feature data frame by using *st_as_sf()* of **sf** packages.

```{r}
listings_sf <- st_as_sf(listings, 
                       coords = c("longitude", "latitude"),
                       crs=4326) %>%
  st_transform(crs = 3414)
```

This results in the creation of a new simple feature data frame - `listings_sf`.

```{r}
glimpse(listings_sf)
```

> Notice that a new column called `geometry` has been added! In addition,`longtitude` and `latitude` columns have both been dropped.

# 6.0 Geoprocessing with sf package

Apart from its capabilities in handling (i.e. importing, exporting, assigning projections, and transforming projections) geospatial data, the **sf** package also encompasses an extensive set of geoprocessing (a.k.a. GIS analysis) functions. Let's now explore some of the commonly used geoprocessing functions!

## 6.1 Buffering

Imagine a bustling town with a popular cycling path that has become a hub for outdoor enthusiasts. The local authority, recognizing the path's significance, has decided to embark on an ambitious project to upgrade and enhance the existing cycling infrastructure. To do so, they need to acquire 5 metres of reserved land on the both sides of the current cycling path. Your role in this exciting venture is to determine the extent of land required and their total area.

Firstly, let’s compute the 5-meter buffers around the cycling paths using the [*st_buffer()*](https://r-spatial.github.io/sf/reference/geos_unary.html) of **sf** package:

```{r}
buffer_cycling <- st_buffer(cyclingpath, 
                               dist=5, nQuadSegs = 30)
```

Next, let's calculate the area of the buffers:

```{r}
buffer_cycling$AREA <- st_area(buffer_cycling)
```

Lastly, let’s find the total land involved with *sum()*:

```{r}
sum(buffer_cycling$AREA)
```

## 6.2 Point-in-polygon count

Here's another scenario:

Let's say that preschool service group is planning to organize future outreach events and is curious about the number of preschools in each Planning Subzone.

We can perform two operations at one go, using both *st_intersects()* and *length()*.

-   [st_intersects()](https://r-spatial.github.io/sf/reference/geos_binary_pred.html): To identify pre-schools located inside each Planning Subzone

-   [*length()*](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/length)*: To* calculate numbers of pre-schools that fall inside each Planning Subzone

```{r}
mpsz3414$`PreSch Count`<- lengths(st_intersects(mpsz3414, preschool3414))
```

We can check the summary statistics of the newly derived `PreSch Count` field by using *summary().*

```{r}
summary(mpsz3414$`PreSch Count`)
```

To list the Planning Subzone with the most number of pre-school, the [*top_n()*](https://dplyr.tidyverse.org/reference/top_n.html) of **dplyr** package.

```{r}
top_n(mpsz3414, 1, `PreSch Count`)
```

Lastly, to find out the density of preschools by Planning Subzone for future outreach events, we will need derive the area of each Planning Subzone using *st_area()* of **sf** package:

```{r}
mpsz3414$Area <- mpsz3414 %>%
  st_area()
```

Next, [*mutate()*](https://dplyr.tidyverse.org/reference/mutate.html) of [**dplyr**](https://dplyr.tidyverse.org/) package is used to compute the density.

```{r}
mpsz3414 <- mpsz3414 %>%
  mutate(`PreSch Density` = `PreSch Count`/Area * 1000000)
```

# 7.0 Exploratory Data Analysis (EDA)

In this section, we will learn how to use appropriate [ggplot2](https://ggplot2.tidyverse.org/) functions to create functional and yet truthful statistical graphs for EDA purposes.

Firstly, we will plot a histogram to reveal the distribution of `PreSch Density` using *hist()* of **R Graphics**.

```{r}
hist(mpsz3414$`PreSch Density`)
```

Although the syntax is very easy to use however the output is far from meeting publication quality. Let's further customize this histogram!

```{r}
ggplot(data=mpsz3414, 
       aes(x= as.numeric(`PreSch Density`)))+
  geom_histogram(bins=20, 
                 color="black", 
                 fill="light blue") +
  labs(title = "Are pre-school even distributed in Singapore?",
       subtitle= "There are many planning sub-zones with a single pre-school, on the other hand, \nthere are two planning sub-zones with at least 20 pre-schools",
      x = "Pre-school density (per km sq)",
      y = "Frequency")
```

> **DIY: Using ggplot2 method, plot a scatterplot showing the relationship between Pre-school Density and Pre-school Count.**

```{r}
ggplot(data=mpsz3414, 
       aes(y = `PreSch Count`, 
           x= as.numeric(`PreSch Density`)))+
  geom_point(color="black", 
             fill="light blue") +
  xlim(0, 40) +
  ylim(0, 40) +
  labs(title = "",
      x = "Pre-school density (per km sq)",
      y = "Pre-school count")
```
